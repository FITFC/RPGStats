package mc.rpgstats.hooky_gen

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*

class HookyProcessor(val environment: SymbolProcessorEnvironment, val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor {
    var invoked = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) return emptyList() else invoked = true

        @Suppress("UNCHECKED_CAST")
        val commands = resolver.getSymbolsWithAnnotation("mc.rpgstats.hooky_gen.api.Command").toList() as List<KSClassDeclaration>
        @Suppress("UNCHECKED_CAST")
        val quickFunctions = resolver.getSymbolsWithAnnotation("mc.rpgstats.hooky_gen.api.RegisterOn").toList() as List<KSFunctionDeclaration>

        commands.forEach {
            logger.info(it.qualifiedName?.asString().toString() )
        }
        logger.info("---")
        quickFunctions.forEach {
            logger.info(it.qualifiedName?.asString().toString())
        }

        val annotatedFunctions = mutableMapOf<String, Pair<KSAnnotation, MutableList<KSFunctionDeclaration>>>()
        quickFunctions.forEach { func ->
            func.annotations.forEach {
                annotatedFunctions.getOrPut(it.arguments[0].value.toString()) { it to mutableListOf() }.second.add(func)
            }
        }

        logger.info("Generating file")
        val commandsFile = codeGenerator.createNewFile(
            Dependencies.ALL_FILES,
            "io.github.silverandro.rpgstats.hooky",
            "Hooky",
            "kt"
        )

        val file = buildString {
            appendLine("// Autogenerated by Hooky subproject, DO NOT EDIT")
            appendLine("package io.github.silverandro.rpgstats.hooky")
            appendLine()
            appendLine("object Hooky {")
            appendLine("    fun registerAll() {")

            if (commands.isNotEmpty()) {
            appendLine("        org.quiltmc.qsl.command.api.CommandRegistrationCallback.EVENT.register { dispatcher, _, _ ->")
            commands.forEach {
            appendLine("            ${it.qualifiedName!!.asString()}.register(dispatcher)")
            }
            appendLine("        }")
            }

            annotatedFunctions.forEach { (_, pair) ->
            append(constructEventAttach(pair.first, pair.second, resolver))
            }

            appendLine("    }")
            appendLine("}")
        }
        commandsFile.write(file.toByteArray())

        return emptyList()
    }

    private fun constructEventAttach(annotation: KSAnnotation, functions: List<KSFunctionDeclaration>, resolver: Resolver): String {
        val fullID = annotation.arguments[0].value.toString()
        val split = fullID.lastIndexOf('.')
        val eventClassName = fullID.substring(0, split)
        val eventName = fullID.substring(split+1)

        val eventClass = resolver.getClassDeclarationByName(resolver.getKSNameFromString(eventClassName))!!
        val eventParam = eventClass.getDeclaredProperties().find { it.simpleName.asString() == eventName }!!
        val specialMethod = (eventParam.type.resolve().arguments[0].type!!.resolve().declaration as KSClassDeclaration)
            .getAllFunctions().find {
                val asString = it.simpleName.asString()
                !(asString == "equals" || asString == "hashCode" || asString == "toString")
            }!!

        logger.info("Managed to resolve `${fullID}` to ${specialMethod.simpleName.asString()} with params ${specialMethod.parameters.map { it.type }}")
        val params = specialMethod.parameters
        functions.forEach {
            verifyParams(params, it.parameters)
        }

        var currentParam = 'a'.dec()
        fun next(): Char { currentParam = currentParam.inc(); return currentParam }

        return buildString {
            if (params.isNotEmpty()) {
                if (fullID == "net.fabricmc.fabric.api.event.player.PlayerBlockBreakEvents.AFTER") {
                    appendLine("        $fullID.register { ${params.joinToString { "${next()}: ${it.type.resolve().declaration.qualifiedName!!.asString()}" }}? ->")
                } else {
                    appendLine("        $fullID.register { ${params.joinToString { "${next()}: ${it.type.resolve().declaration.qualifiedName!!.asString()}" }} ->")
                }
            } else {
                appendLine("        $fullID.register { ")
            }
            functions.forEach {
                var passParam = 'a'.dec()
                fun new(): Char { passParam = passParam.inc(); return passParam }
                if (it.parameters.isNotEmpty()) {
                    appendLine("            ${it.qualifiedName!!.asString()}(${it.parameters.joinToString { new().toString() }})")
                } else {
                    appendLine("            ${it.qualifiedName!!.asString()}()")
                }
            }
            appendLine("        }")
        }
    }

    private fun verifyParams(absoluteSet: List<KSValueParameter>, toCheck: List<KSValueParameter>) {
        if (toCheck.size > absoluteSet.size) throw IllegalStateException("Too large parameter list! Was expecting at most ${absoluteSet.size}, but got ${toCheck.size}")

        toCheck.forEachIndexed { index, parameter ->
            val expected = parameter.type.resolve()
            var actual = absoluteSet[index].type.resolve()

            if (!actual.isMarkedNullable) {
                actual = actual.makeNotNullable()
            }

            logger.info(actual.isMarkedNullable.toString())
            if (expected != actual) {
                throw IllegalStateException("Parameter mismatch! Expected $expected but got $actual at index $index")
            }
        }
    }
}